import XCTest
import MixboxGenerators
import MixboxStubbing

// swiftlint:disable multiline_arguments
final class GeneratorFacadeTests: BaseGeneratorTestCase {
    private let unstubbedInt = 1234567890
    private let unstubbedString = "1234567890"
    
    func test___generate___is_stateless() {
        stubConstants()
        
        var book: Book
            
        book = generator.generate {
            $0.id = 1
            $0.title = "Hamlet"
        }
        
        XCTAssertEqual(book.id, 1)
        XCTAssertEqual(book.title, "Hamlet")
        
        // Generation in this case should be stateless
        // Generation should give an ability to fill fields partially.
        
        book = generator.generate {
            $0.title = "War and Peace"
        }
        
        XCTAssertEqual(book.id, unstubbedInt)
        XCTAssertEqual(book.title, "War and Peace")
    }
    
    // Values generated by default should be constant all the time.
    // This is done by seeding random generator with a constant.
    // This is done to make test failures reproduceable.
    func test___generate___is_reporducable() {
        let book: Book = generator.generate()
        
        XCTAssertEqual(book.id, 2947667278772165694)
        XCTAssertEqual(book.title, "")
        XCTAssertEqual(book.author.id, -144895307711186549)
        XCTAssertEqual(book.author.name, "NJA8GJGRxnuC1")
    }
    
    func test___generate___can_stub_nested_types() {
        stubConstants()
        
        let book: Book = generator.generate {
            $0.author.stub {
                $0.id = 2
                $0.name = "William Shakespeare"
            }
        }
        
        XCTAssertEqual(book.id, unstubbedInt)
        XCTAssertEqual(book.title, unstubbedString)
        XCTAssertEqual(book.author.id, 2)
        XCTAssertEqual(book.author.name, "William Shakespeare")
    }
    
    func test___generate___provides_ability_to_generate_deeply_nested_objects() {
        stubConstants()

        let book: Book = generator.generate(type: Book.self) {
            $0.pages = [
                "stubbed string",
                $0.generate()
            ]
        }

        XCTAssertEqual(book.pages, ["stubbed string", unstubbedString])
    }
    
    func test___generate___provides_ability_to_generate_deeply_nested_objects_by_fields() {
        stubConstants()
        
        let book = generator.generate(type: Book.self) {
            $0.author = $0.generate {
                $0.id = 2
                $0.name = "William Shakespeare"
            }
        }
        
        XCTAssertEqual(book.author.id, 2)
        XCTAssertEqual(book.author.name, "William Shakespeare")
    }
    
    func test___generate___can_generate_non_final_classes() {
        mocks.register(type: ByFieldsGenerator<TitledEntity>.self) { _ in
            ByFieldsGenerator<TitledEntity> { fields in
                try TitledEntity(
                    title: fields.title.get()
                )
            }
        }
        
        let entity: TitledEntity = generator.generate {
            $0.title = "How to title a book for dummies."
        }
        
        XCTAssertEqual(entity.title, "How to title a book for dummies.")
    }
    
    func test___stub() {
        stubConstants()
        
        generator.stub(type: Book.self) {
            $0.id = 1
        }
        
        let book: Book = generator.generate()
        
        XCTAssertEqual(book.id, 1)
    }
    
    func test___generate___can_generate_CaseIterable_enums() {
        // High-level check. Checks that it works
        
        let value = generator.generate() as CaseIterableEnum
        
        XCTAssert(CaseIterableEnum.allCases.contains(value))
        
        // Low-level check. Checks that it is random. Relies on implementation.
        
        mocks.register(type: RandomNumberProvider.self) { _ in
            ConstantRandomNumberProvider(0)
        }
        
        XCTAssertEqual(
            generator.generate() as CaseIterableEnum,
            CaseIterableEnum.allCases[0]
        )
        
        mocks.register(type: RandomNumberProvider.self) { _ in
            ConstantRandomNumberProvider(1)
        }
        
        XCTAssertEqual(
            generator.generate() as CaseIterableEnum,
            CaseIterableEnum.allCases[1]
        )
    }
    
    func test___generate___can_generate_enums_with_associated_values() {
        stubConstants()
        
        func assert(randomInts: UInt64..., expectedValue: CaseGeneratableEnumWithAssociatedValues) {
            mocks.register(type: RandomNumberProvider.self) { _ in
                SequenceRandomNumberProvider(randomInts)
            }
            
            XCTAssertEqual(
                generator.generate() as CaseGeneratableEnumWithAssociatedValues,
                expectedValue
            )
        }
        
        let unstubbedBook = Book(
            id: unstubbedInt,
            pages: [],
            author: Author(
                id: unstubbedInt,
                name: unstubbedString
            ),
            title: unstubbedString
        )
        
        // High-level check. Checks that it works. It shouldn't fail test.
        
        _ = generator.generate() as CaseGeneratableEnumWithAssociatedValues
        
        // Low-level check. Relies on implementation.
        
        assert(
            randomInts: 0,
            expectedValue: .case_0_no_associated_value
        )
        
        assert(
            randomInts: 1,
            expectedValue: .case_1_primitive(unstubbedInt)
        )
        
        assert(
            randomInts: 2, 1,
            expectedValue: .case_2_nesting_same_type(.case_1_primitive(unstubbedInt))
        )
        
        assert(
            randomInts: 3,
            expectedValue: .case_3_nesting_class(unstubbedBook)
        )
        
        assert(
            randomInts: 4,
            expectedValue: .case_4_nesting_multiple_values(unstubbedBook, unstubbedBook)
        )
    }
    
    func test___generate___fails_test_if_CaseGeneratable_DefaultGeneratorProvider_returns_empty_allCasesGenerators() {
        assertFails {
            _ = generator.generate() as CaseGeneratableEnumWithoutCases
        }
    }
    
    private func setRandom(_ values: UInt64...) {
        mocks.register(type: RandomNumberProvider.self) { _ in
            SequenceRandomNumberProvider(values)
        }
    }

    private func stubConstants() {
        mocks.register(type: Generator<Int>.self) { [unstubbedInt] _ in
            ConstantGenerator(unstubbedInt)
        }
        mocks.register(type: Generator<String>.self) { [unstubbedString] _ in
            ConstantGenerator(unstubbedString)
        }
    }
}

private indirect enum CaseGeneratableEnumWithAssociatedValues: Equatable, CaseGeneratable, DefaultGeneratorProvider {
    case case_0_no_associated_value
    case case_1_primitive(Int)
    case case_2_nesting_same_type(CaseGeneratableEnumWithAssociatedValues)
    case case_3_nesting_class(Book)
    case case_4_nesting_multiple_values(Book, Book)
    
    static func ==(lhs: Self, rhs: Self) -> Bool {
        switch (lhs, rhs) {
        case (.case_0_no_associated_value, .case_0_no_associated_value):
            return true
        case let (.case_1_primitive(lhs), .case_1_primitive(rhs)):
            return lhs == rhs
        case let (.case_2_nesting_same_type(lhs), .case_2_nesting_same_type(rhs)):
            return lhs == rhs
        case let (.case_3_nesting_class(lhs), .case_3_nesting_class(rhs)):
            return lhs == rhs
        case let (.case_4_nesting_multiple_values(lhs), .case_4_nesting_multiple_values(rhs)):
            return lhs.0 == rhs.0 && lhs.1 == rhs.1
        default:
            return false
        }
    }
    
    static let allCasesGenerators: AllCasesGenerators<Self> = [
        { _ in .case_0_no_associated_value },
        { .case_1_primitive(try $0.generate()) },
        { .case_2_nesting_same_type(try $0.generate()) },
        { .case_3_nesting_class(try $0.generate()) },
        { .case_4_nesting_multiple_values(try $0.generate(), try $0.generate()) }
    ]
}

private enum CaseGeneratableEnumWithoutCases: Equatable, CaseGeneratable, DefaultGeneratorProvider {
    static let allCasesGenerators: AllCasesGenerators<Self> = []
}

private enum CaseIterableEnum: String, Equatable, CaseIterable, DefaultGeneratorProvider {
    case case0
    case case1
}

// To check how generators work with classes
private final class Book: TitledEntity, Equatable, InitializableWithFields {
    let id: Int // Primitive
    let pages: [String] // Array
    let author: Author // Class
    
    // Example of an ordinary constructor. Is not required in a real application for generators to work.
    init(
        id: Int,
        pages: [String],
        author: Author,
        title: String)
    {
        self.id = id
        self.pages = pages
        self.author = author
        
        super.init(title: title)
    }
    
    // `InitializableWithFields`
    init(fields: Fields<Book>) throws {
        id = try fields.id.get()
        pages = try fields.pages.get()
        author = try fields.author.get()
        
        try super.init(
            fields: fields
        )
    }
    
    static func ==(lhs: Book, rhs: Book) -> Bool {
        return lhs.id == rhs.id && lhs.pages == rhs.pages && lhs.title == rhs.title && lhs.author == rhs.author
    }
}

// To check how generators work with non-final classes
private class TitledEntity: RepresentableByFields {
    let title: String
    
    // Example of an ordinary constructor. Is not required in a real application for generators to work.
    init(title: String) {
        self.title = title
    }
    
    // Constructor to reuse in classes that are `InitializableWithFields`.
    init<T: TitledEntity>(fields: Fields<T>) throws {
        title = try fields.title.get()
    }
}

// To check how generators work with structs
private struct Author: Equatable, InitializableWithFields {
    let id: Int
    let name: String
    
    // Example of an ordinary constructor. Is not required in a real application for generators to work.
    init(
        id: Int,
        name: String)
    {
        self.id = id
        self.name = name
    }
    
    // `InitializableWithFields`
    init(fields: Fields<Author>) throws {
        id = try fields.id.get()
        name = try fields.name.get()
    }
}
